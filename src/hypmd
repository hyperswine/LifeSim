#pragma once

#include "hmath"

#include <utility>

typedef struct __cell{
    // Matrix of N x 3, of all positions of the particles in the cell
    qmatrix M;

} CELL;

typedef struct __cell_list{
    // x, y, z ranges
    quadruple x[2];
    quadruple y[2];
    quadruple z[2];
    
    // e.g. cell[0] -> cell[0][0][0] represents the main cell
    // cell[5] -> cell[5/k_cells + r]. The user doesn not have to worry about cell arithmetic,
    // ewald summation automatically computes nearest image of all possible cells
    CELL* all_cells;

    int k_cells;

    // N particles in the cell
    int N;

    CELL* operator[](int i){ return all_cells[i]; }
    CELL* begin() { return all_cells; }
    CELL* end() { return all_cells + k_cells; }

} CELL_LIST;

// A wrapper around a vector representing the count of neighboring cells
typedef struct _verlet_list{
    hvec<> v_list;
} V_LIST;

struct _verlet_table{
    // for each particle, contains all nearest image neighbors
    // basically, particle i -> [(j, 0), (k, 2) ...]
    hmatrix<std::pair<int,int>> neighbors;

    int N;
} V_TABLE;
